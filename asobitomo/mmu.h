#pragma once

#include <array>
#include <stdexcept>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>

using namespace std;

#include "types.h"
#include "ppu.h"

class MMU {
public:
  std::vector<int> accessed;

    struct Header {
      byte boot_rom[0x100];

      uint16_t nop;
      uint16_t jmp;

      byte logo[48];

      char title[0x0b];
      char designation[4];
      char licensee[2];

      byte sgb_compatible;
      byte cart_type;
      byte rom_size;
      byte ram_size;
      byte destination;
      byte old_licensee;
      byte mask_rom_version;
      byte complement_cksum;
      byte cksum;
    };
  MMU(std::string path, PPU& ppu): accessed(0xff7f - 0xff00, 0), bank(0), mem(), cart(32768, 0), rom_mapped(true), ppu(ppu), joypad(0xf) {
    fill(mem.begin(), mem.end(), 0);

    std::ifstream f(path);
    f.read((char*)cart.data(), 32768);
  }

  void set(word loc, byte value) {
    // std::cout << hex<<loc << std::endl;
    mem[loc] = value;
    if (!rom_mapped && value != 0x0 && (loc == 0xff42 || loc == 0xff43)) {
      // scroll
      ;
    }
    
    if (!rom_mapped && loc >= 0x8000 && loc <= 0x97ff && value != 0x2f && value != 0x00) {
      ; // writing to VRAM
    }
    
    if (!rom_mapped && loc >= 0xfe00 && loc <= 0xfe9f) {
      ; // writing to sprite OAM
    }
    
    if (!rom_mapped && loc >= 0x9800 && loc <= 0x9bff) {
      ; // writing to background tilemap 1
    }
    
    if (loc == 0x7ff3) {
      ;
    }
    
    if (loc >= 0x2000 && loc <= 0x3fff) {
      if (value == 0x00) {
        bank = 1;
      } else {
        bank = value & 0x1f;
      }
    }
    
    if (loc == 0xff40) {
      // LCD stat
      if (value & (1 << 7)) {
        ppu.set_lcd(true);
      } else {
        ppu.set_lcd(false);
      }
    }

    if (loc == 0xff46) {
      word src = value << 8;
      for (word addr = 0xfe00; addr < 0xfea0; ++addr) {
        (*this)[addr] = (*this)[src++];
      }
    }
      
    if (loc == 0xff50) { // unmap rom
      rom_mapped = false;
    }
  }

  byte& operator[](int loc) {
    if (loc < 0x0000 || loc > RAM_BYTES) {
      throw std::range_error("invalid location");
    }

    byte& result = _read_mem(loc);
    // cerr << "mmu["
    //   << setfill('0') << setw(4) <<
    //   hex << loc << dec
    //   << "] = " << setfill('0') << setw(2) <<
    //   hex << static_cast<int>(result) << dec << endl;

    return result;
  }

  // const byte& operator[](word loc) const;
  byte& _read_mem(int loc) {
    if (loc == 0x415f) {
    ; // writing tile data?
    // called by 27c3
    // called by 27d7
    // called by 036c
    
    }
    if (loc == 0x020c) {
    ; // beginning of code
    }

    if (loc >= 0xff00 && loc <= 0xff7f) {
      accessed[loc - 0xff00]++;
    }

    if (loc == 0xff46) { // DMA
      return mem[loc];
    }
    
    if (loc == 0xff00) { //joypad
      return joypad;
    }

    if (loc <= 0x00ff) {
      // std::cout << "rom" << std::endl;
      if (rom_mapped)
        return rom[loc];
      else
        return cart[loc];
    } else if (loc <= 0x014f) {
      // std::cout << "a" << std::endl;
      return cart[loc]; /* header */
    } else if (loc <= 0x3fff) {
      // std::cout << "here" << std::endl;
      return cart[loc]; /* rom bank 0 0x150 - 0x3fff */
    } else if (loc <= 0x7fff) {
      /* rom bank switchable 0x4000 - 0x7fff */
//      return cart[bank * 0x4000 + loc];
      return cart[loc]; /* TODO: this only works on non-MBC */
    } else if (loc <= 0x97ff) {
      return mem[loc]; /* RAM 0x8000 - 0x97ff */
    } else if (loc <= 0x9bff) {
      /* 0x9800 - 0x9bff */
      return mem[loc]; /* is this right? */
    } else if (loc <= 0x9fff) {
      /* 0x9c00 - 0x9fff */
      return mem[loc]; /* is this right? */
    } else if (loc <= 0xbfff) {
      /* 0xa000 - 0xbfff */
      return mem[loc]; /* is this right? */
    } else if (loc <= 0xcfff) {
      return mem[loc]; /* 0xc000 - 0xcfff */
    } else if (loc <= 0xdfff) {
      return mem[loc]; /* 0xd000 - 0xdfff */
    } else if (loc <= 0xfdff) {
      /* 0xe000 - 0xfdff ==
         0xc000 - 0xcdff */
      return mem[loc - 0x2000];
    } else if (loc <= 0xfe9f) {
      return mem[loc]; /* 0xfe00 - 0xfe9f */
    // } else if (loc <= 0xfeff) {
    // } else if (loc <= 0xff7f) {
    // } else if (loc <= 0xfffe) {
    //
    // } else if (loc == 0xffff) {
    //
    //
    } else {
      return mem[loc];
    }
  }

// private:
  static constexpr int RAM_BYTES = 65536;
  static constexpr word CARTRIDGE_TYPE_OFFSET = 0x0147;

  PPU& ppu;
  byte bank;
  std::array<byte, RAM_BYTES> mem;
  std::vector<byte> rom {
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB,
    0x21, 0x26, 0xFF, 0x0E, 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
    0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0, 0x47, 0x11, 0x04, 0x01,
    0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22,
    0x23, 0x05, 0x20, 0xF9, 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
    0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, 0xF9, 0x2E, 0x0F, 0x18,
    0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20,
    0xF7, 0x1D, 0x20, 0xF2, 0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
    0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06, 0x7B, 0xE2, 0x0C, 0x3E,
    0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17,
    0xC1, 0xCB, 0x11, 0x17, 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83,
    0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63,
    0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
    0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C, 0x21, 0x04, 0x01, 0x11,
    0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE,
    0x3E, 0x01, 0xE0, 0x50
  };
  std::vector<byte> cart;

  bool rom_mapped;
  byte joypad;
};
