#pragma once

#include <array>
#include <stdexcept>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <memory>

using namespace std;

#include "sdl_input.h"
#include "types.h"
#include "ppu.h"
#include "apu.h"
#include "timer.h"
#include "mbc_types.h"
#include "mbc_base.h"
#include "header_type.h"
#include "rang.hpp"
#include "util.h"

extern bool in_title;

class MMU {
public:
  MMU(std::string filename, PPU& ppu, APU& apu, Timer& timer):
    path(filename),
    cart(32768, 0), rom_mapped(true), ppu(ppu), apu(apu), timer(timer),
    joypad(0xf),
    input(), mbc() {
    fill(mem.begin(), mem.end(), 0);
    std::copy(rom.begin(), rom.end(), mem.begin());
    
    mem[0xf000] = 0xff;

    byte header_bytes[0x50];
    std::ifstream f(path);
    f.seekg(0x100);
    f.read((char*)header_bytes, 0x50);
    Header* h = reinterpret_cast<Header*>(header_bytes);
    header = *h;
      
    long rom_size = 1 << (15 + h->rom_size);
    cart.resize(rom_size);
    
    MBC cartridge_type = h->cartridge_type;
    mbc = mbc_for(cartridge_type, *this);
    auto load_path = replace_path_extension(path, ".gb", ".sav");
    mbc->load(load_path);

    ppu.screen->add_exit_handler([this]() {
      auto sav_path = replace_path_extension(path, ".gb", ".sav");
      mbc->save(sav_path);
    });
      
    f.seekg(0);
    f.read((char*)cart.data(), rom_size);
  }

  void set(word loc, byte value);

  byte& operator[](word loc);
  
  void dump_cartridge_info() {
    std::cout << rang::style::dim << rang::fg::gray << "Title\t\t" << rang::fg::black << rang::style::reset << (char*)header.title_or_manufacturer.title << rang::fg::reset << rang::style::reset << std::endl;
    std::cout << rang::style::dim << rang::fg::gray << "Type\t\t" << rang::fg::black << rang::style::reset  << header.cartridge_type << rang::fg::reset << rang::style::reset << std::endl;
    std::cout << rang::style::dim << rang::fg::gray << "ROM\t\t" << rang::fg::black << rang::style::reset << (1 << (15 + header.rom_size)) << rang::fg::reset << rang::style::reset << std::endl;
    std::cout << rang::style::dim << rang::fg::gray << "RAM\t\t" << rang::fg::black << rang::style::reset << static_cast<int>(header.ram_size) << rang::fg::reset << rang::style::reset << std::endl;
    std::cout << rang::style::dim << rang::fg::gray << "SGB\t\t" << rang::fg::black << rang::style::reset << static_cast<int>(header.sgb == 0x3) << rang::fg::reset << rang::style::reset << std::endl;
    std::cout << rang::style::dim << rang::fg::gray << "NJP\t\t" << rang::fg::black << rang::style::reset  << static_cast<int>(header.destination) << rang::fg::reset << rang::style::reset << std::endl;
  }
  
  void handle_joypad();

// private:
  static constexpr word CARTRIDGE_TYPE_OFFSET = 0x0147;

  const std::string path;

  PPU& ppu;
  APU& apu;
  Timer& timer;
  
  std::array<byte, 0x100> rom {
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB,
    0x21, 0x26, 0xFF, 0x0E, 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
    0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0, 0x47, 0x11, 0x04, 0x01,
    0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22,
    0x23, 0x05, 0x20, 0xF9, 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
    0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, 0xF9, 0x2E, 0x0F, 0x18,
    0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20,
    0xF7, 0x1D, 0x20, 0xF2, 0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
    0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06, 0x7B, 0xE2, 0x0C, 0x3E,
    0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17,
    0xC1, 0xCB, 0x11, 0x17, 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83,
    0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63,
    0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
    0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C, 0x21, 0x04, 0x01, 0x11,
    0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE,
    0x3E, 0x01, 0xE0, 0x50
  };
  std::vector<byte> cart;
  
  static constexpr int RAM_BYTES = 65536;
  std::array<byte, RAM_BYTES> mem;

  bool rom_mapped;
  byte joypad;
  
  SDLInput input;
  
  Header header;
  
  int i = 0;
  char last;
  
  std::unique_ptr<MBCBase> mbc;
};



